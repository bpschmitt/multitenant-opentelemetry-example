apiVersion: opentelemetry.io/v1beta1
kind: OpenTelemetryCollector
metadata:
  name: opentelemetry-collector-deployment
  namespace: observability
spec:
  mode: deployment
  serviceAccount: otel-collector
  # Add container-level security context
  securityContext:
    runAsUser: 0
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
  env:
    - name: MY_POD_IP
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
    - name: K8S_NODE_NAME
      valueFrom:
        fieldRef:
          fieldPath: spec.nodeName
    - name: K8S_NODE_IP
      valueFrom:
        fieldRef:
          fieldPath: status.hostIP
    - name: NEW_RELIC_LICENSE_KEY
      valueFrom:
        secretKeyRef:
          key: license-key
          name: newrelic-license-key
    - name: NEW_RELIC_LICENSE_KEY_TENANT1
      valueFrom:
        secretKeyRef:
          key: license-key
          name: newrelic-license-key-tenant1
    - name: NEW_RELIC_LICENSE_KEY_TENANT2
      valueFrom:
        secretKeyRef:
          key: license-key
          name: newrelic-license-key-tenant2
    - name: K8S_CLUSTER_NAME
      value: "openshift"

  config:

    exporters:

      debug: {}

      debug/detailed:
        verbosity: detailed

      otlphttp/gateway:
        endpoint: http://opentelemetry-collector-gateway-collector.observability.svc.cluster.local:4318

    extensions:
      health_check:
        endpoint: ${env:MY_POD_IP}:13133

    processors:
      batch: {}

      filter/keep_low_data_metrics:
        metrics:
          include:
            match_type: regexp
            metric_names:
              # Matches OTLP (k8s.node...) AND Infrastructure (node.cpu...)
              - ^(k8s\.)?(node|pod|container|cluster|volume|deployment|daemonset|statefulset|hpa)\..*$
              
              # Matches Prometheus (node_cpu..., container_memory...)
              - ^(node|container|kube)_(cpu|memory|network|fs|filesystem|node|pod|deployment|daemonset|statefulset|hpa|resourcequota)_.*$

      resource/newrelic:
        attributes:
          # We set the cluster name to what the customer specified in the helm chart
          - key: k8s.cluster.name
            action: upsert
            value: "openshift"
          - key: "newrelic.chart.version"
            action: upsert
            value: 0.0.0
          - key: newrelic.entity.type
            action: upsert
            value: "k8s"

      k8sattributes/ksm:
        # Metadata attached by this processor is reliant on the uid & pod name. This would be sufficient for most types
        # of metrics but there are cases of metrics such as kube_node* where a uid would not be present and thus metadata would
        # not be attached. To address cases like these, metadata attributes must be annotated in a different manner
        # such as by preserving some of the attributes presented by KSM.
        auth_type: "serviceAccount"
        passthrough: false
        extract:
          metadata:
            - k8s.deployment.name
            - k8s.daemonset.name
            - k8s.namespace.name
            - k8s.node.name
            - k8s.pod.start_time
            - k8s.replicaset.name
            - k8s.statefulset.name
            - k8s.cronjob.name
            - k8s.job.name
        pod_association:
          - sources:
            - from: resource_attribute
              name: k8s.pod.uid
          - sources:
            - from: resource_attribute
              name: k8s.pod.name

      transform/ksm:
        metric_statements:
          - delete_key(resource.attributes, "k8s.node.name")
          - delete_key(resource.attributes, "k8s.namespace.name")
          - delete_key(resource.attributes, "k8s.pod.uid")
          - delete_key(resource.attributes, "k8s.pod.name")
          - delete_key(resource.attributes, "k8s.container.name")
          - delete_key(resource.attributes, "k8s.replicaset.name")
          - delete_key(resource.attributes, "k8s.deployment.name")
          - delete_key(resource.attributes, "k8s.statefulset.name")
          - delete_key(resource.attributes, "k8s.daemonset.name")
          - delete_key(resource.attributes, "k8s.job.name")
          - delete_key(resource.attributes, "k8s.cronjob.name")
          - delete_key(resource.attributes, "k8s.replicationcontroller.name")
          - delete_key(resource.attributes, "k8s.hpa.name")
          - delete_key(resource.attributes, "k8s.resourcequota.name")
          - delete_key(resource.attributes, "k8s.volume.name")
          - set(resource.attributes["k8s.pod.uid"], resource.attributes["uid"])
          - set(resource.attributes["k8s.node.name"], resource.attributes["node"])
          - set(resource.attributes["k8s.namespace.name"], resource.attributes["namespace"])
          - set(resource.attributes["k8s.pod.name"], resource.attributes["pod"])
          - set(resource.attributes["k8s.container.name"], resource.attributes["container"])
          - set(resource.attributes["k8s.replicaset.name"], resource.attributes["replicaset"])
          - set(resource.attributes["k8s.deployment.name"], resource.attributes["deployment"])
          - set(resource.attributes["k8s.statefulset.name"], resource.attributes["statefulset"])
          - set(resource.attributes["k8s.daemonset.name"], resource.attributes["daemonset"])
          - set(resource.attributes["k8s.job.name"], resource.attributes["job_name"])
          - set(resource.attributes["k8s.cronjob.name"], resource.attributes["cronjob"])
          - set(resource.attributes["k8s.replicationcontroller.name"], resource.attributes["replicationcontroller"])
          - set(resource.attributes["k8s.hpa.name"], resource.attributes["horizontalpodautoscaler"])
          - set(resource.attributes["k8s.resourcequota.name"], resource.attributes["resourcequota"])
          - set(resource.attributes["k8s.volume.name"], resource.attributes["persistentvolume"])
          - set(resource.attributes["k8s.pvc.name"], resource.attributes["persistentvolumeclaim"])
          - delete_key(resource.attributes, "uid")
          - delete_key(resource.attributes, "node")
          - delete_key(resource.attributes, "namespace")
          - delete_key(resource.attributes, "pod")
          - delete_key(resource.attributes, "container")
          - delete_key(resource.attributes, "replicaset")
          - delete_key(resource.attributes, "deployment")
          - delete_key(resource.attributes, "statefulset")
          - delete_key(resource.attributes, "daemonset")
          - delete_key(resource.attributes, "job_name")
          - delete_key(resource.attributes, "cronjob")
          - delete_key(resource.attributes, "replicationcontroller")
          - delete_key(resource.attributes, "horizontalpodautoscaler")
          - delete_key(resource.attributes, "resourcequota")
          - delete_key(resource.attributes, "persistentvolume")
          - delete_key(resource.attributes, "persistentvolumeclaim")

      cumulativetodelta:
        exclude:
          metrics:
            - 'kube_pod_container_status_restarts_total'
          match_type: strict

      memory_limiter:
        check_interval: 5s
        limit_percentage: 80
        spike_limit_percentage: 25

      transform/nr:
        metric_statements:
        - context: datapoint
          statements:
          - set(attributes["newrelic.entity.type"], "k8s") where IsMatch(instrumentation_scope.name,
            ".*(kubeletstatsreceiver|k8sclusterreceiver|k8seventsreceiver|prometheusreceiver).*")

      transform/promote_job_label:
        metric_statements:
        - context: datapoint
          statements:
          - set(instrumentation_scope.attributes["job_label"], datapoint.attributes["job_label"]) where datapoint.attributes["job_label"] != nil

      transform/events:
        log_statements:
          - context: log
            statements:
              - set(log.attributes["event.source.host"], resource.attributes["k8s.node.name"])

      transform/convert_timestamp:
        metric_statements:
          - context: datapoint
            conditions:
              - IsMatch(metric.name, "kube_pod_container_status_last_terminated_timestamp")
            statements:
              - set(datapoint.attributes["kube_pod_container_status_last_terminated_timestamp_formatted"], FormatTime(Unix(Int(datapoint.value_double)), "%Y-%m-%dT%H:%M:%SZ"))

      groupbyattrs:
        keys:
          - pod
          - uid
          - container
          - daemonset
          - replicaset
          - statefulset
          - deployment
          - cronjob
          - configmap
          - job
          - job_name
          - horizontalpodautoscaler
          - persistentvolume
          - persistentvolumeclaim
          - endpoint
          - mutatingwebhookconfiguration
          - validatingwebhookconfiguration
          - lease
          - storageclass
          - secret
          - service
          - resourcequota
          - node
          - namespace

      transform/ksm_datapoints:
        metric_statements:
          - set(resource.attributes["k8s.volume.name"], datapoint.attributes["volumename"])
          - delete_key(datapoint.attributes, "volumename")

      metricstransform/k8s_cluster_info:
        transforms:
          - include: kubernetes_build_info
            action: update
            new_name: k8s.cluster.info

      metricstransform/kube_pod_container_status_phase:
        transforms:
          - include: 'kube_pod_container_status_waiting'
            match_type: strict
            action: update
            new_name: 'kube_pod_container_status_phase'
            operations:
            - action: add_label
              new_label: container_phase
              new_value: waiting
          - include: 'kube_pod_container_status_running'
            match_type: strict
            action: update
            new_name: 'kube_pod_container_status_phase'
            operations:
            - action: add_label
              new_label: container_phase
              new_value: running
          - include: 'kube_pod_container_status_terminated'
            match_type: strict
            action: update
            new_name: 'kube_pod_container_status_phase'
            operations:
            - action: add_label
              new_label: container_phase
              new_value: terminated

      resource/events:
        attributes:
          - key: "newrelic.event.type"
            action: upsert
            value: "OtlpInfrastructureEvent"
          - key: "category"
            action: upsert
            value: "kubernetes"
          - key: k8s.cluster.name
            action: upsert
            value: "openshift"
          - key: "newrelic.chart.version"
            action: upsert
            value: 0.0.0

    receivers:
      prometheus/controlplane:
        config:
          scrape_configs:
            - job_name: apiserver
              scrape_interval: 1m
              kubernetes_sd_configs:
                - role: endpoints
                  namespaces:
                    names:
                      - default
              scheme: https
              tls_config:
                ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                insecure_skip_verify: true
              bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
              relabel_configs:
              - action: keep
                source_labels:
                - __meta_kubernetes_namespace
                - __meta_kubernetes_service_name
                - __meta_kubernetes_endpoint_port_name
                regex: default;kubernetes;https
              - action: replace
                source_labels:
                - __meta_kubernetes_namespace
                target_label: namespace
              - action: replace
                source_labels:
                - __meta_kubernetes_service_name
                target_label: service
              - action: replace
                target_label: job_label
                replacement: apiserver

      prometheus/ksm:
        config:
          scrape_configs:
            - job_name: kube-state-metrics
              scrape_interval: 30s
              kubernetes_sd_configs:
                - role: pod
              relabel_configs:
                - action: keep
                  regex: kube-state-metrics
                  source_labels:
                  - __meta_kubernetes_pod_label_app_kubernetes_io_name
                - action: replace
                  target_label: job_label
                  replacement: kube-state-metrics

      k8s_cluster:
        collection_interval: 30s
        node_conditions_to_report: [Ready, MemoryPressure]
        allocatable_types_to_report: [cpu, memory, ephemeral-storage]

      k8s_events: {}

      otlp:
        protocols:
          grpc:
            endpoint: ${env:MY_POD_IP}:4317
          http:
            endpoint: ${env:MY_POD_IP}:4318
            
    service:
      extensions:
      - health_check

      pipelines:

        logs/k8s_events:
          exporters:
          - otlphttp/gateway
          processors:
          - memory_limiter
          - resource/events
          - transform/events
          - batch
          receivers:
          - k8s_events

        metrics/ksm:
          receivers:
          - prometheus/ksm
          processors:
          - memory_limiter
          - filter/keep_low_data_metrics
          - cumulativetodelta
          - resource/newrelic
          - metricstransform/kube_pod_container_status_phase
          - metricstransform/k8s_cluster_info
          - transform/ksm_datapoints
          - transform/convert_timestamp
          - groupbyattrs
          - transform/nr
          - transform/ksm
          - k8sattributes/ksm
          - batch
          exporters:
          - otlphttp/gateway

        metrics/nr_controlplane:
          receivers:
            - prometheus/controlplane
          processors:
            - memory_limiter
            - filter/keep_low_data_metrics
            - metricstransform/k8s_cluster_info
            - resource/newrelic
            - cumulativetodelta
            - batch
          exporters:
            - otlphttp/gateway

      telemetry:
        metrics:
          level: "basic"
          readers:
            - periodic:
                exporter:
                  otlp:
                    protocol: http/protobuf
                    endpoint: "https://otlp.nr-data.net"
                    headers:
                      - name: api-key
                        value: "${NEW_RELIC_LICENSE_KEY}"